# Массивы

Время, мин: 45
Дата изучения: March 24, 2023
Изучено: Yes
Содержание: 1. Форма записи массива
2. Структура
3. Сравнение массива с объектом
4. Методы массивов (push, shift, forEach, pop, unshift, map, reduce)
Тип занятия: Лекция

***Массив*** - это объект с цифровыми именами свойств.

---

Существует два **формата записи** массива:

1. **в [ ]** 
2. путем присвоения переменной массива, созданного **с помощью класса new Array** 

```jsx
const myArray2 = new Array(1, 2, 3) // создание нового экземпляра класса Array
```

**!!! Важно** — **два этих массива, созданных разными путями - не равны друг другу**, тк массив = объект, ссылочный тип → при создании нового массива, создаются две разные ссылки. 

- Метод [Array.isArray(value)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray). Он возвращает `true`, если `value`массив, и `false`, если нет

---

**Поддержка массивом “thisArg”**

- Методы find, filter, map - в параметре принимают `thisAr`

```jsx
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users.filter(user => army.canJoin(user));

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

---

**Структура массива**

- все элементы (формат ключ-значение)
- доп свойство **length —** содержит актуальное количество элементов в массиве. Соотносится с индексами таким образом — **берет индекс последнего элемента + 1. (проверка в виде задания свойства для 99го индекса)**

---

**Сравнение массива с объектом**

1. **Различие прототипов** — для массива - Array; для объекта - Object — влияют какие методы могут быть доступны для объекта или массива. 
2. **Поле length** — в массиве будет менятся автоматически. 
3. **Доступ к свойству** — для массива - доступ к элементу только через [ ], тк свойства в **цифровом** формате *(кроме свойства **length**)* 
4. **Порядок** элементов **в массиве важен!!!**
5. **Добавление или изменение свойств в массиве** — происходит с помощью [ ]

---

---

                                                  **МЕТОДЫ ДОБАВЛЕНИЯ/УДАЛЕНИЯ**

---

**Методы массивов —** функции высшего порядка в массивах, методы прототипов.

Каждый созданный массив является экземпляром **Массива (Array) и ему доступны данные методы**

- push
- shift
- forEach
- pop
- unshift
- map

*Все они мутируют исходный массив*

***Метод PUSH*** 

- *добавляет элемент в конец массива*

---

***Метод POP*** 

- *удаление последнего элемента в массиве + возвращает удаленный элемент*

---

***Метод UNSHIFT*** 

- *доабвление элемента в начало массива*

---

***Метод SPLICE*** 

- ***добавлять, удалять и заменять элементы.***
- Возвращает массив из удалённых элементов.
- допускается использование отрицательных индексов.

```jsx
arr.splice(start[, deleteCount, elem1, ..., elemN])

arr.splice(0, 3, "Давай", "танцевать"); // начинает с 0 индекса и удаляет 3 элемента и заменяет из на два
```

---

***Метод SLICE*** 

- Он возвращает новый массив, в который копирует все элементы с индекса `start`
 до `end` (не включая `end`)
- можно задать отрицательные числа
- **можно использовать для копирования нового массива** —!!!

```jsx
arr.slice([start], [end])
```

---

***Метод CONCAT***

- создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.
- копирует только элементы из массивов
- если массивоподобный объект имеет специальное свойство `Symbol.isConcatSpreadable`, то он обрабатывается как массив, с помощью `concat`: вместо него добавляются его элементы:

---

***Метод SHIFT*** 

- *удаляет первый элемент в массиве + возвращает удаленный элемент*

```jsx
const myArray = new Array (1, true, 3, 4)

myArray.push(4) // используем метод push и вызываем ее передавая аргумент
const lastNumb = myArray.pop() // убираем последний элемент массива и присваиваем переменной 
```

---

***Метод forEach***  

- *перебирает все элементы массива, возвращает undefined, не меняет исходный массив!!!*
- применяем практически во всех случаях
- **НО!** может использоваться цикл **for … of** — когда нужно использовать остановку цикла **(break, continue)**

В **аргумент** принимает **три значения:**

- **element** - тот элемент, который мы перебираем
- **i** - номер по порядку
- **arr** - ссылка на тот массив, который мы перебираем

```jsx
const myArray = [1, 2, 3]

myArray.forEach(el => console.log (el * 2)) // при вызове массива в аргумент передается callback-функция
// при каждом вызове колбке функции значения параметра будет менятся на каждый последующий элемент массива
console.log(myArray)

массив.forEach(function(элемент, индекс, массив) {
	код, который выполнится для всех элементов
})
```

---

                                         **МЕТОДЫ ПОИСКА В МАССИВЕ**

---

1. **МЕТОД** `arr.indexOf(item, from)` 
    - ищет `item` начиная с индекса `from` и **возвращает номер индекса**, на котором был найден искомый элемент, в противном случае `-1`.
2. **МЕТОД**  `arr.includes(item, from)` 
    - ищет `item` начиная с индекса `from` и **возвращает `true`**, если поиск успешен.
    - используют строгое сравнение `===`
    - правильно обрабатывает **NaN**.
3. **МЕТОД** arr.find 
    - используется если в массиве **есть объекты**

```jsx
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
```

1. **МЕТОД** [arr.findIndex](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)
    - возвращает индекс, на котором был найден элемент, а не сам элемент
2. **МЕТОД** filter
    - возвращает массив из всех подходящих элементов:
    
    ```jsx
    let results = arr.filter(function(item, index, array) {
      // если `true` -- элемент добавляется к results и перебор продолжается
      // возвращается пустой массив в случае, если ничего не найдено
    });
    ```
    

---

                                                  **МЕТОДЫ ПРЕОБРАЗОВАНИЯ МАССИВА**

---

1. ***Метод MAP*** 
    - *ожидает в качестве аргумента колбек-функцию. **НО возвращает абсолютно новый массив!!! Поэтому необходимо присваивать результат вызова MAP новой переменной!***

```jsx
const myArray = [1, 2, 3]

const newArray = myArray.map(el => el + 2); //неявная форма возврата резултата функции

console.log(newArray)

const newArray = myArray.map((el) => {
return el + 2
}; //явная форма возврата резултата функции, ОБЯЗАТЕЛЬНО указываем return!!!

console.log(newArray)
```

1. ***Метод SORT*** 
    - метод сортировки, **все элементы сортируются как строки (по-символьно)**

```jsx
const str = prompt('', '')
const products = str.split(', ') // получаем массив
products.sort()
```

**! НО данный метод принимает колбек-функцию**

- стоит отметить, что данный метод использует также метод быстрой сортировки
- Таким образом мы можем обойти данную особенность этого метода

```jsx
arr.sort(compareNum)
function compareNum (a, b) {
    return a - b;
}

ИЛИ 

function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}
```

1. ***Метод SPLIT*** 
    - превращает данные “string” в массив, при этом **указывается в аргументе - разделитель**
    - без аргумента - возвращает массив с буквами

```jsx
const str = prompt('', '')
const products = str.split(', ')

console.log(products)
```

---

1. ***Метод JOIN*** 
    - объединение элементов массива в одну строку

```jsx
const str = prompt('', '')
const products = str.split(', ') // получаем массив

console.log(products.join(';') // преобразовываем масси в строку
```

1. ***Метод REDUCE [Классы и прототипы](%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B%20%D0%B8%20%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D1%8B%20edb680c2930a483d892c5834b6e839ec.md)*** 
    - для вычисления единого значения на основе всего массива.

```jsx
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);

let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```

- в аргумент также принимает:
    1. **стрелочную колбэк-функцию**, которая принимает два параметра: **el** → значение которое будет прибавлятся к аккумулятору при каждой итерации, **acc** → аккумулятор, отдельная переменная, которая изменяется в процессе итерации вызова функции
    2. **initial** - начальное значение аккумулятора. Если не указан, то беретеся первый элемент и функция начинает со второго элемента. 
- [arr.reduceRight](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight) - проходит по массиву справа налево