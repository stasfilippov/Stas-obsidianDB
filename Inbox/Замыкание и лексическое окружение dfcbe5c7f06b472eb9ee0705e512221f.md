# Замыкание и лексическое окружение

Изучено: Yes

**Лексическое окружение —** у каждой выплняемой функции, блока кода, скрипта есть связанные с ними внутренние (скрытый объект - лексическое окружение)

- *Переменная* – это **свойство специального внутреннего объекта**, связанного с текущим выполняющимся блоком/функцией/скриптом.
- *Работа с переменными* – это на самом деле **работа со свойствами этого объекта**.
    - Оно делится на **внутреннее** и **внешнее**.
        - *Внутреннее* - объект, как свойство. в котором хранятся все локальные переменные функции, а также **this.** Он имеет ссылку на **внешний объект (внешнее логическое окружение)**
        - *Внешнее* - это объект, в котором располагаются свойства соответствующие коду снаружи функции
    - **Каждый новый вызов функции — создание нового лексического окружения**
    - **После выполнения функции** - ее лексическое окружении **уничтожается**

**Например**: 

- Function Declaration → лексическое окружение создается уже до того, как она будет объявлена.

---

**Вложенная функция** 

- **Все функции «при рождении» получают скрытое свойство `[[Environment]]`, которое ссылается на лексическое окружение места, где они были созданы.**
- При этом стоит отметить **как это реализовываться** - откуда функция знает, что ей помещать в лексическое окружение - это связано со свойством **environment** — ссылается на то **лексическое окружение места**, в котором была создана функция. Т.е. функция **myFunction()** была создана **в лексическом окружении createCounter**, поэтому она и видит перменную counter (имеет ссылку)

```jsx
function createCounter() {
    let counter = 0;

    const myFunction = function () {debugger
        counter = counter + 1; debugger // сохраняет ссылки, которые ей были доступны на момент создания, даже после удаления логического окружения
        return counter;debugger
    }

    return myFunction;
}
debugger
const increment = createCounter();debugger//по сути вызываем функцию myFunction()
const c1 = increment();debugger
const c2 = increment();debugger
const c3 = increment();debugger

console.log(c1, c2, c3);
```

- Вызов функции таким образом — **sum(5)(-1)**

```jsx
const sum = function(a) {
    return function (b) {
        return a + b;
    }
}

console.log(sum(1)(2))
sum(5)(-1)
```

---

Пожалуйста, обратите внимание, как здесь работает управление памятью. Хотя **createCounter`()`** закончил выполнение некоторое время назад, его лексическое окружение остаётся в памяти, потому что есть вложенная функция с `[[Environment]]`, который ссылается на него.

В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, которая может его использовать. И только тогда, когда таких не остаётся, окружение уничтожается.

---

Таким образом, имеется такое понятие как **замыкание**

- это функция, которая запоминает свои внешние переменные и может получить к ним доступ. Все функции в JavaScript являются замыканиями (есть только одно исключение, про которое будет рассказано в [Синтаксис "new Function"](https://learn.javascript.ru/new-function)).

---

**Лексическое окружение для блока кода и циклов**

- *IF*

Когда выполнение попадает в блок `if`, для этого блока создаётся новое лексическое окружение.

- *For, while*

Для цикла у каждой итерации своё отдельное лексическое окружение

```jsx
for (let i = 0; i < 10; i++) {
  // У каждой итерации цикла своё собственное лексическое окружение
  // {i: value}
}

alert(i); // Ошибка, нет такой переменной
```

- *Блоки кода*

В браузере все скрипты (кроме `type="module"`) разделяют одну общую глобальную область. Так что, если мы создадим глобальную переменную в одном скрипте, она станет доступна и в других. Но это становится **источником конфликтов**, если **два скрипта используют одно и то же имя переменной** и перезаписывают друг друга.